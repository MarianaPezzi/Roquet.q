"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatBotImpl = void 0;
const debug_1 = __importDefault(require("debug"));
const events_1 = require("events");
const model_1 = require("../model");
const sdk_1 = __importDefault(require("../sdk"));
const context_1 = require("./context");
const debug = debug_1.default('beekeeper:bot');
/**
 * Event carrying a new message
 */
const EVENT_LISTENER_KEY = 'message:create';
/**
 * Interval for time out to keep the event loop busy
 */
const TIMEOUT_INTERVAL = 60000;
/**
 * A ChatBot implementation to interact with the SDK
 * @implements ChatBot
 */
class ChatBotImpl extends events_1.EventEmitter {
    /**
     * Constructs a new chat bot from a SDK
     * @param sdk
     */
    constructor(sdk) {
        super();
        this.sdk = sdk;
    }
    /**
     * Creates and returns a new chat bot instance from a passed SDK.
     * To work correctly, the SDK needs to have realtime communication enabled.
     * @param sdk to be used by the chat bot
     * @returns a chat bot instance
     */
    static withSDK(sdk) {
        return new ChatBotImpl(sdk);
    }
    /**
     * Creates and returns a new chat bot instance based on the credentials
     * @param credentials to be used for the SDK of the chat bot
     * @returns a new chat bot
     */
    static withCredentials(credentials) {
        return new ChatBotImpl(new sdk_1.default(credentials, { realtime: true }));
    }
    async messageHandler(message) {
        const user = await this.sdk.getMe();
        if (!message.user_id.isSame(user.id)) {
            debug(`New message from user_id: ${message.user_id}`);
            const ctx = new context_1.ContextImpl(message, this.sdk);
            this.emit('message', message, ctx);
        }
    }
    attachListeners() {
        this.sdk.on(EVENT_LISTENER_KEY, (event) => this.messageHandler(model_1.toMessage(event.data)));
    }
    start() {
        // Keep event loop busy to not shutdown
        this._keepAliveTimeout = setInterval(() => null, TIMEOUT_INTERVAL);
        this.attachListeners();
        debug('Started bot');
        this.emit('started');
    }
    stop() {
        if (this._keepAliveTimeout) {
            clearInterval(this._keepAliveTimeout);
        }
    }
    getMe() {
        return this.sdk.getMe();
    }
    async message(user, messageData) {
        const conversation = await this.sdk.Conversations.byProfile(user);
        const me = await this.getMe();
        const message = model_1.messageFactory(me, conversation, messageData);
        const response = await this.sdk.Messages.create(message);
        return response;
    }
    async post(stream, postData) {
        const me = await this.getMe();
        const post = model_1.postFactory(me, stream, postData);
        const response = await this.sdk.Posts.create(post);
        return response;
    }
}
exports.ChatBotImpl = ChatBotImpl;
