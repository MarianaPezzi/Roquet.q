"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Realtime = void 0;
const debug_1 = __importDefault(require("debug"));
const events_1 = require("events");
const pubnub_1 = __importDefault(require("pubnub"));
const event_1 = require("./event");
const debug = debug_1.default('beekeeper:realtime');
/** Default parameters for Pubnub */
const defaultsPubnub = {
    origin: 'pubsub.pubnub.com',
    heartbeatInterval: 30,
    ssl: true,
};
/** Crypto options used for decrypting Pubnub messages */
const cryptoOptions = {
    keyEncoding: 'base64',
    encryptKey: false,
};
/**
 * A class provided realtime events sent by the Beekeeper API to all clients
 */
class Realtime extends events_1.EventEmitter {
    constructor(credentials) {
        super();
        this._status = null;
        this._cipherKey = null;
        if (credentials.cipherKey) {
            this._cipherKey = credentials.cipherKey;
        }
        const pubnubConfig = Object.assign({}, defaultsPubnub, {
            subscribeKey: credentials.subscribeKey,
        });
        this._pubnub = new pubnub_1.default(pubnubConfig);
        this.attachListeners();
    }
    /**
     * Subscribes to a channel in order to receive events
     * @param {string} channel to subscribe to
     */
    subscribe(channel) {
        this._pubnub.subscribe({ channels: [channel] });
    }
    /**
     * @returns {boolean} true if connected otherwise false
     */
    isConnected() {
        return this._status === pubnub_1.default.CATEGORIES.PNConnectedCategory;
    }
    attachListeners() {
        this._pubnub.addListener({
            status: (statusEvent) => this.statusHandler(statusEvent),
            message: (messageEvent) => this.messageHandler(messageEvent),
        });
    }
    statusHandler(event) {
        this._status = event.category;
    }
    messageHandler(event) {
        const { message } = event;
        if (typeof message === 'string') {
            const event = this.getEvent(message);
            let eventKind;
            if (event.hasOwnProperty('action')) {
                eventKind = `${event.type}:${event.action}`;
            }
            else {
                eventKind = `${event.type}`;
            }
            debug(`New event: ${eventKind}`);
            this.emit(eventKind, event);
        }
    }
    getEvent(message) {
        let msg;
        if (this._cipherKey) {
            msg = this._pubnub.decrypt(message, this._cipherKey, cryptoOptions);
        }
        else {
            msg = message;
        }
        if (typeof msg !== 'object') {
            msg = {};
        }
        msg.data = msg.data || message;
        msg.type = msg.type || event_1.EventTypes.EVENT;
        return msg;
    }
}
exports.Realtime = Realtime;
