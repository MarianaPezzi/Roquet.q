"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileResourceImpl = void 0;
const model_1 = require("../../model");
const resource_1 = require("./resource");
const error_1 = __importDefault(require("./error"));
const environment_1 = require("../../utils/environment");
const BASE_PATH = '/api/2/files';
let fileUploadDependencies;
function isFileUploadResult(uploadResult) {
    return typeof uploadResult === 'object' && 'id' in uploadResult;
}
function loadFileUploadDependencies() {
    if (!fileUploadDependencies) {
        fileUploadDependencies = {
            axios: environment_1.tryLoading(() => require('axios'), 'Please install `axios` for file upload support'),
        };
        if (!environment_1.isBrowser()) {
            fileUploadDependencies.FormData = environment_1.tryLoading(() => require('form-data'), 'Please install `form-data` for Node.js file upload support');
        }
    }
    return fileUploadDependencies;
}
function extractKeyFromS3Response(xmlResponse) {
    /* Yes, we're touching XML with regex here, but we're not trying to parse arbitrary XML.
     * We just need to extract a very specific piece of information out of it, so our sanity
     * should not take too much damage due to it.  */
    const matches = xmlResponse.match(/<Key>([^<]+)<\/Key>/m);
    if (!matches) {
        throw new SyntaxError('Failed to parse S3 response');
    }
    return matches[1].trim();
}
const Paths = {
    token(usageType) {
        return `${BASE_PATH}/${usageType}/upload/token`;
    },
    register(usageType) {
        return `${BASE_PATH}/${usageType}/upload`;
    },
};
class FileResourceImpl extends resource_1.Resource {
    /**
     * Upload the given file to Beekeeper.
     *
     * @param metadata Metadata about the file
     * @param body The file's contents. In Browsers, `Blob`s and `File`s are accepted. On Node.js, you can pass
     *             `Buffer`s and `OutputStream`s as file body.
     * @param onUploadProgress Callback that gets called upon progress.
     */
    async create(metadata, body, onUploadProgress) {
        // Make sure they are available before we're grabbing the token
        loadFileUploadDependencies();
        const token = await this.getToken(metadata.usage_type, metadata.media_type);
        const uploadResult = await this.uploadFile(metadata, body, token, onUploadProgress);
        // uploadFile() gave us a `File` already, so we can use it as is
        if (isFileUploadResult(uploadResult)) {
            return uploadResult;
        }
        // We got a file key, we need to register it
        return this.registerFile(metadata, uploadResult);
    }
    getToken(usageType, mediaType) {
        return this.request({
            path: Paths.token(usageType),
            method: resource_1.Methods.GET,
            query: {
                media_type: mediaType,
            },
        });
    }
    async registerFile(metadata, key) {
        const payload = {
            key: key,
            ...metadata,
        };
        return model_1.toFile(await this.request({
            path: Paths.register(metadata.usage_type),
            method: resource_1.Methods.POST,
            body: payload,
        }));
    }
    async uploadFile(metadata, body, token, onUploadProgress) {
        var _a;
        const deps = loadFileUploadDependencies();
        const axios = deps.axios;
        const headers = {};
        let uploadForm;
        let uploadProgressHandler = null;
        if (typeof FormData !== 'undefined') {
            uploadForm = new FormData();
            for (const { name, value } of token.additional_form_data) {
                uploadForm.append(name, value);
            }
            uploadForm.append(token.file_param_name, body, metadata.name);
            // We assume that we're in the browser here and axios has working progress tracking.
            if (onUploadProgress) {
                uploadProgressHandler = ({ loaded, total }) => onUploadProgress({ done: loaded, total: total });
            }
        }
        else if (typeof deps.FormData !== 'undefined') {
            const FormData = deps.FormData;
            uploadForm = new FormData();
            for (const { name, value } of token.additional_form_data) {
                uploadForm.append(name, value);
            }
            uploadForm.append(token.file_param_name, body, {
                contentType: metadata.media_type,
                filename: metadata.name,
                knownLength: (_a = metadata.size) !== null && _a !== void 0 ? _a : undefined,
            });
            Object.assign(headers, uploadForm.getHeaders(), {
                // S3 requires the content-length to be known in advance
                'Content-Length': uploadForm.getLengthSync(),
            });
            // TODO: Axios on node.js doesn't support onUploadProgress: https://github.com/axios/axios/issues/1793
            //       We'll need to observe the stream to emulate it for node.
        }
        else {
            throw new Error('No FormData implementation available');
        }
        try {
            if (token.upload_url.startsWith('/')) {
                // It's uploading to the tenant API rather than S3, attach authentication headers
                for (const header of this.defaultHeaders) {
                    headers[header.name] = header.value;
                }
            }
            const requestConfig = {
                baseURL: this.basePath,
                headers: headers,
                responseType: 'text',
                transformResponse: [],
            };
            if (uploadProgressHandler) {
                requestConfig.onUploadProgress = uploadProgressHandler;
            }
            const response = await axios.post(token.upload_url, uploadForm, requestConfig);
            // Direct upload to S3, the most likely path to be encountered
            if (token.registration_required &&
                token.upload_response_data_type === 'xml') {
                return extractKeyFromS3Response(response.data);
            }
            // The upload endpoint gave us a file already, let's use it
            if (!token.registration_required &&
                token.upload_response_data_type === 'json') {
                return model_1.toFile(JSON.parse(response.data));
            }
            // If we end up here, we have a unsupported combination of registration
            // requirement & response format. Fall through to below to bail out.
        }
        catch (e) {
            if (e.response) {
                throw new error_1.default(e.response.status, 'Failed to upload file');
            }
            throw e;
        }
        throw new Error('File upload not supported for this tenant');
    }
}
exports.FileResourceImpl = FileResourceImpl;
